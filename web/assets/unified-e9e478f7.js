import{b as O}from"./bail-0fe607cf.js";import{e as m}from"./extend-c40a5e11.js";import{t as T}from"./trough-69dd48ea.js";import{V as I}from"./vfile-33e078b6.js";function z(t){if(typeof t!="object"||t===null)return!1;const e=Object.getPrototypeOf(t);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in t)&&!(Symbol.iterator in t)}const S=function(t){const n=this.constructor.prototype,i=n[t],c=function(){return i.apply(c,arguments)};Object.setPrototypeOf(c,n);const a=Object.getOwnPropertyNames(i);for(const p of a){const u=Object.getOwnPropertyDescriptor(i,p);u&&Object.defineProperty(c,p,u)}return c},C={}.hasOwnProperty;class P extends S{constructor(){super("copy"),this.Compiler=void 0,this.Parser=void 0,this.attachers=[],this.compiler=void 0,this.freezeIndex=-1,this.frozen=void 0,this.namespace={},this.parser=void 0,this.transformers=T()}copy(){const e=new P;let r=-1;for(;++r<this.attachers.length;){const n=this.attachers[r];e.use(...n)}return e.data(m(!0,{},this.namespace)),e}data(e,r){return typeof e=="string"?arguments.length===2?(b("data",this.frozen),this.namespace[e]=r,this):C.call(this.namespace,e)&&this.namespace[e]||void 0:e?(b("data",this.frozen),this.namespace=e,this):this.namespace}freeze(){if(this.frozen)return this;const e=this;for(;++this.freezeIndex<this.attachers.length;){const[r,...n]=this.attachers[this.freezeIndex];if(n[0]===!1)continue;n[0]===!0&&(n[0]=void 0);const i=r.call(e,...n);typeof i=="function"&&this.transformers.use(i)}return this.frozen=!0,this.freezeIndex=Number.POSITIVE_INFINITY,this}parse(e){this.freeze();const r=d(e),n=this.parser||this.Parser;return w("parse",n),n(String(r),r)}process(e,r){const n=this;return this.freeze(),w("process",this.parser||this.Parser),g("process",this.compiler||this.Compiler),r?i(void 0,r):new Promise(i);function i(c,a){const p=d(e),u=n.parse(p);n.run(u,p,function(o,f,h){if(o||!f||!h)return s(o);const l=f,y=n.stringify(l,h);F(y)?h.value=y:h.result=y,s(o,h)});function s(o,f){o||!f?a(o):c?c(f):r(void 0,f)}}}processSync(e){let r=!1,n;return this.freeze(),w("processSync",this.parser||this.Parser),g("processSync",this.compiler||this.Compiler),this.process(e,i),j("processSync","process",r),n;function i(c,a){r=!0,O(c),n=a}}run(e,r,n){E(e),this.freeze();const i=this.transformers;return!n&&typeof r=="function"&&(n=r,r=void 0),n?c(void 0,n):new Promise(c);function c(a,p){const u=d(r);i.run(e,u,s);function s(o,f,h){const l=f||e;o?p(o):a?a(l):n(void 0,l,h)}}}runSync(e,r){let n=!1,i;return this.run(e,r,c),j("runSync","run",n),i;function c(a,p){O(a),i=p,n=!0}}stringify(e,r){this.freeze();const n=d(r),i=this.compiler||this.Compiler;return g("stringify",i),E(e),i(e,n)}use(e,...r){const n=this.attachers,i=this.namespace;if(b("use",this.frozen),e!=null)if(typeof e=="function")u(e,r);else if(typeof e=="object")Array.isArray(e)?p(e):a(e);else throw new TypeError("Expected usable value, not `"+e+"`");return this;function c(s){if(typeof s=="function")u(s,[]);else if(typeof s=="object")if(Array.isArray(s)){const[o,...f]=s;u(o,f)}else a(s);else throw new TypeError("Expected usable value, not `"+s+"`")}function a(s){if(!("plugins"in s)&&!("settings"in s))throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");p(s.plugins),s.settings&&(i.settings=m(!0,i.settings,s.settings))}function p(s){let o=-1;if(s!=null)if(Array.isArray(s))for(;++o<s.length;){const f=s[o];c(f)}else throw new TypeError("Expected a list of plugins, not `"+s+"`")}function u(s,o){let f=-1,h=-1;for(;++f<n.length;)if(n[f][0]===s){h=f;break}if(h===-1)n.push([s,...o]);else if(o.length>0){let[l,...y]=o;const x=n[h][1];z(x)&&z(l)&&(l=m(!0,x,l)),n[h]=[s,l,...y]}}}}const B=new P().freeze();function w(t,e){if(typeof e!="function")throw new TypeError("Cannot `"+t+"` without `parser`")}function g(t,e){if(typeof e!="function")throw new TypeError("Cannot `"+t+"` without `compiler`")}function b(t,e){if(e)throw new Error("Cannot call `"+t+"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")}function E(t){if(!z(t)||typeof t.type!="string")throw new TypeError("Expected node, got `"+t+"`")}function j(t,e,r){if(!r)throw new Error("`"+t+"` finished async. Use `"+e+"` instead")}function d(t){return A(t)?t:new I(t)}function A(t){return!!(t&&typeof t=="object"&&"message"in t&&"messages"in t)}function F(t){return typeof t=="string"||D(t)}function D(t){return!!(t&&typeof t=="object"&&"byteLength"in t&&"byteOffset"in t)}export{B as u};
